---
title: "Forecasting demographic variables"
subtitle: "The library `demography`"
author: "Pedro Delicado"
date: 'Simposio de Estadística, Ibagué, Colombia. 2023'
output: 
  html_document:
    number_sections: true
    toc: true
---

```{r setup, include=FALSE}
#knitr::opts_chunk$set(echo = TRUE, eval=FALSE)
knitr::opts_chunk$set(echo = TRUE, eval=TRUE)
```

# Library `demography`. An introduction

```{r, message=FALSE}
library(demography)
```

This library was developed by 
[**Rob Hyndman**](https://robjhyndman.com/) 
and his research team. 

From the package's help:

> **Forecasting mortality and fertility data** <br>
> *Description*<br>
> Functions for demographic analysis including lifetable calculations, Lee-Carter modelling and <br>
functional data analysis of mortality rates.
>
> **Author(s)** <br>
> **Rob J Hyndman** with contributions from Heather Booth, Leonie Tickle, John Maindonald, Simon Wood and the R Core Team.
>
>Maintainer: [**Rob Hyndman**](https://robjhyndman.com/) 


## An example: French mortality data

> `fr.mort` contains French mortality rates and populations (1899-2005) for ages 0-110. Data taken from the Human Mortality Database on 20 February 2008.
> `fr.sm` contains a smoothed version of `fr.mort` obtained using the `smooth.demogdata` function.

```{r}
class(fr.mort)
#help(demogdata)
names(fr.mort)
names(fr.mort$rate)
dim(fr.mort$rate$total)
```

We plot the mortality rate function corresponding to an specific calendar year: 
```{r}
plot(fr.mort,years=1990,type='p',pch=1)
lines(fr.sm,years=1990)
```

Now We plot the set of mortality rate functions, one for each calendar year: 

```{r}
plot(fr.mort)
```

And the smoothed version: 
```{r}
plot(fr.sm)
```

## Fitting a model for demographic data

Let $y_t(s)$ be a demographic characteristic $y$ corresponding to age $s$ measured at calendar year $t$, in a given population (that is, a country or region of interest).

Observations of $y_t(s)$ are done for years $t=t_0, t_0+1,\ldots, t_f$, and for 
ages $s\in \{s_1,\ldots,s_n\}\subset [s_0,s_f]$.
It is assumed that 
\[
y_t(s_i)=m_t(s_i) + \varepsilon_{t,s_i},
\]
where $m_t(s_i)$ is a *random smooth function* of $s$ (and usually also in $t$).

That is, $m_t(s_i)$ is a realization of a *functional random variable*.

It is assumed that $m_t(s_i)$ verify the sufficient conditions for admitting a 
Karhunen-Loève decomposition
\[
m_t(s)=\mu(s) + \sum_{k=1}^{\infty} \beta_{t,k} \phi_k(s), \,\, s\in[s_0,s_f].
\]

For $t=t_0,\ldots,t_f$, the data $y_t(s_i)$, $i=1,\ldots,n$, are smoothed to estimate the function $m_t(s)$, $s\in [s_0,s_f]$.
Let $\tilde{m}_t(s)$ be the smoothed functions. 

Then Functional Principal Components Analysis is applied to the functional data set $\{\tilde{m}_t(s): t=t_0,\ldots,t_f\}$ to obtain an estimation of the truncated Karhunen-Loève decomposition: 
\[
\tilde{m}_t(s)=\hat{\mu}(s) + \sum_{k=1}^{K} \hat{\beta}_{t,k} \hat{\phi}_k(s), \,\, s\in[s_0,s_f].
\]

```{r}
france.fit <- fdm(fr.mort,order=2)
france.fit
```

```{r}
par(mar=c(4,4,1.5,1))
plot(france.fit)
```

```{r}
class(france.fit)
names(france.fit)
```

The element `basis` of the fitted model has the fitted mean as a first column.
The following columns are the functional principal components used to fit the data:
```{r}
dim(france.fit$basis)
```

```{r, fig.height=10,fig.width=8}
par(mfrow=c(2,1))
plot(fr.mort,col=8)
lines(france.fit$basis[,1],lwd=4)
eig_val_1 <- var(france.fit$coeff[,2])
lines(france.fit$basis[,1]+sqrt(eig_val_1)*france.fit$basis[,2],lwd=4,col="red",lty=3)
lines(france.fit$basis[,1]-sqrt(eig_val_1)*france.fit$basis[,2],lwd=4,col="blue",lty=3)
legend("topleft",c("mean + 1st FPC ", "mean", "mean - 1st FPC "),
       lty=c(3,1,3), col=c(2,1,4), lwd=4, bty="n",seg.len = 1.5)
legend("top",paste0("1st FPC: ",round(100*france.fit$varprop[1],1),"% variation"), bty="n")

plot(fr.mort,col=8)
lines(france.fit$basis[,1],lwd=4)
eig_val_2 <- var(france.fit$coeff[,3])
cte=5
lines(france.fit$basis[,1]+cte*sqrt(eig_val_2)*france.fit$basis[,3],lwd=4,col="red",lty=3)
lines(france.fit$basis[,1]-cte*sqrt(eig_val_2)*france.fit$basis[,3],lwd=4,col="blue",lty=3)
legend("topleft",c("mean + 2nd FPC ", "mean", "mean - 2nd FPC "),
       lty=c(3,1,3), col=c(2,1,4), lwd=4, bty="n",seg.len = 1.5)
legend("top",paste0("2nd FPC: ",round(100*france.fit$varprop[2],1),"% variation"), bty="n")
```

The element `coeff` of the fitted model has first column equal to one.
The following columns are the scores of each calendar year at the corresponding functional principal components used to fit the data:
```{r}
dim(france.fit$coeff)
```

```{r}
plot(france.fit$coeff[,2],france.fit$coeff[,3],type="l",as=1,
     main="1st versus 2nd FPC scores of each calendar years",
     xlab="beta1: Scores at 1st FPC", ylab="beta2: Scores at 2nd FPC")
text(france.fit$coeff[,2],france.fit$coeff[,3],france.fit$year,pos=1,cex=.5)
abline(v=0,h=0,col=8)
```

Internally, these scores are stored as time series:

```{r}
plot(france.fit$coeff[,2:3], main="1st and 2nd FPC scores as time series")
```

## Forecasting of a demographic variable

We write again the estimation of the truncated Karhunen-Loève decomposition: 
\[
\tilde{m}_t(s)=\hat{\mu}(s) + \sum_{k=1}^{K} \hat{\beta}_{t,k} \hat{\phi}_k(s), \,\, s\in[s_0,s_f].
\]
To forecast $y_t(s)$, we need forecasts of $\hat{\beta}_{t,k}$, for $t\ge t_f+1$ and 
$k=1,\dots,K$.

That is, we have to forecast the time series of the scores in the FPCs.

The library `dmography` calls the function `auto.arima` from the librry `forecast`,
also developed and maintained by [**Rob Hyndman**](https://robjhyndman.com/).


```{r}
france.fcast <- forecast(france.fit,50)
models(france.fcast)
```

```{r}
par(mar=c(4,4,1.5,1))
plot(france.fcast,'c')
```

```{r}
plot(france.fcast)
```

```{r} 
plot(fr.sm,col=8,ylim=c(-10.2,2))
lines(france.fcast)
text(42,-8,"Forecasts for 50 years ahead (2007-2056)",cex=1,pos=4)
```

# Working with population pyrmids in library `demography`

```{r}
load("Smoothed_Poulation_Pyramids.RData")
# PopPyrSm, PopPyrRelSm, Year, egAge.1, Country
```


## Colombia, absolute population pyramids

We start transforming a data set of population pyramids into a `demogdata` object. 
Function `demogdata` creates the basic objects for library `demography`.
Unfortunately, the library was designed to work with only three types of demographic data: either **mortality**, **fertility** or **migration**.

We will use this library for **population pyramids**, and more specifically with
**age-symmetric population histogram**. Even though we must specify one of the three types of demographic data the library `demography` is expecting.

In this case we state `"mortality"`, but other choices are also valid. 
It is important to specify `lambda=1` because this parameter indicates which Box-Cox transformation is applied to the data before start any analysis. For mortality data, the default value is `lambda=0`, meaning logarithm transformation. 
For `lambda=1` there is no transformation.


```{r, warning=FALSE} 
ctr <- 'CO' 
ppDemog <- demogdata(data=t(PopPyrSm[ctr,,]), 
                     pop=t(PopPyrSm[ctr,,]), 
                     ages=egAge.1, years=Year, 
                     type= "mortality", label=Country[ctr,1],
                     name="Total", lambda=1) 
plot(ppDemog, datatype = "rate", # It is possible to use datatype="pop"
     main=paste0(Country[ctr,1],": absolute population (",Year[1],"-", rev(Year)[1],")")) 
```

### Modeling and forecasting popultion pyramids


```{r}
ppDemog.fit <- fdm(ppDemog, order=2)
ppDemog.fit
```

```{r}
par(mar=c(4,4,1.5,1))
plot(ppDemog.fit)
```

<!-- Note in the previous graphics that the **Main effects** are positive in this example.-->

```{r, fig.height=10,fig.width=8}
par(mfrow=c(2,1))
plot(ppDemog,col=8, 
     main=paste0(Country[ctr,1],": absolute population (",Year[1],"-", rev(Year)[1],")"))
lines(ppDemog$age, 1+ppDemog.fit$basis[,1],lwd=4)
eig_val_1 <- var(ppDemog.fit$coeff[,2])
lines(ppDemog$age, 1+ppDemog.fit$basis[,1]+sqrt(eig_val_1)*ppDemog.fit$basis[,2],lwd=4,col="red",lty=3)
lines(ppDemog$age, 1+ppDemog.fit$basis[,1]-sqrt(eig_val_1)*ppDemog.fit$basis[,2],lwd=4,col="blue",lty=3)
legend("topleft",c("mean + 1st FPC ", "mean", "mean - 1st FPC "),
       lty=c(3,1,3), col=c(2,1,4), lwd=4, bty="n",seg.len = 1.5)
legend("topright",paste0("1st FPC: ",round(100*ppDemog.fit$varprop[1],1),"% variation"), bty="n")


plot(ppDemog,col=8, 
     main=paste0(Country[ctr,1],": absolute population (",Year[1],"-", rev(Year)[1],")"))
lines(ppDemog$age, 1+ppDemog.fit$basis[,1],lwd=4)
eig_val_2 <- var(ppDemog.fit$coeff[,3])
cte=1
lines(ppDemog$age, 1+ppDemog.fit$basis[,1]+cte*sqrt(eig_val_2)*ppDemog.fit$basis[,3],lwd=4,col="red",lty=3)
lines(ppDemog$age, 1+ppDemog.fit$basis[,1]-cte*sqrt(eig_val_2)*ppDemog.fit$basis[,3],lwd=4,col="blue",lty=3)
legend("topleft",c("mean + 2nd FPC ", "mean", "mean - 2nd FPC "),
       lty=c(3,1,3), col=c(2,1,4), lwd=4, bty="n",seg.len = 1.5)
legend("topright",paste0("2nd FPC: ",round(100*ppDemog.fit$varprop[2],1),"% variation"), bty="n")
```

```{r}
plot(ppDemog.fit$coeff[,2],ppDemog.fit$coeff[,3],type="l",as=1,cex=.5,
     main="1st versus 2nd FPC scores of each calendar years",
     xlab="beta1: Scores at 1st FPC", ylab="beta2: Scores at 2nd FPC")
abline(v=0,h=0,col=8)
```

```{r}
plot(ppDemog.fit$coeff[,2:3], main="1st and 2nd FPC scores as time series")
```

Now, forecasts are computed for a horizon of `r (horiz<-20)` years: 
```{r}
if (!exists("horiz")) horiz <- 20
ppDemog.fcast <- forecast(ppDemog.fit,h=horiz)
models(ppDemog.fcast)
```

```{r}
par(mar=c(4,4,1.5,1))
plot(ppDemog.fcast,'c')
```

```{r}
plot(ppDemog.fcast,
     main=paste0(Country[ctr,1],": absolute population (",rev(Year)[1]+1,"-", rev(Year)[1]+horiz,")"))
```

```{r,warning=FALSE} 
plot(ppDemog, datatype = "rate", col=8,
     main=paste0(Country[ctr,1],
                 ": absolute population (",Year[1],"-",
                 rev(Year)[1]+horiz,")"),
     ylim=c(0,550))
plot(ppDemog.fcast,add=TRUE)
```

### Ploting results as population pyramids

We plot now as population pyramids the modeling and forecasting results.

```{r, echo=FALSE}
# matplot_pop_pyr_1y matplot for a population pyramids dataset
#                    with precision of 1 yr
# Arguments:
#
# age:   ages at which each row of matrix_pop_pyr is evaluated 
# matrix_pop_pyr 
#    Each row:    a population pyramid, first Male, then Female
#    Each column: an age, negative for Male, positive for Female
# orderM:  -1 (1) if Male is sorted in decreasing (increasing) order
matplot_pop_pyr_1y <- 
  function(age=NULL, matrix_pop_pyr, orderM = -1, 
           col=1:8, colM=col, colF=col, lty=1:8,
           main="",
           xlim=max(abs(matrix_pop_pyr)), ...){
  max_age <- dim(matrix_pop_pyr)[2]/2
  if (orderM==-1) 
    matrix_pop_pyr[,1:max_age] <- matrix_pop_pyr[,max_age:1]
  n <- dim(matrix_pop_pyr)[1]
  pop_pyr <- as.numeric(matrix_pop_pyr[1,])
  if (is.null(age)){
    age <- 1:max_age -1
  } else {
    age <- age[age>0]
  }
  plot(-pop_pyr[1:max_age],age, type="l", lwd=1, col=colM[1],
       lty=lty[1],
       xlim=xlim*c(-1,1), ylim=c(0,100),
       xlab="",
       ylab="Age",
       main=main,
       axes=FALSE, ...)
  lines(pop_pyr[(max_age+1):(2*max_age)],age, lwd=1, lty=lty[1], col=colF[1], ...)
  abline(h=0)
  abline(v=0,col=8)
  segments(x0=rep(-.0005,5),y0=seq(20,100,by=20),x1=rep(.0005,5),col=8)
  axis(side=2, at=seq(0,100,by=20))
  #axis(side=1, at=seq(-.02,.02,by=.005), pos=0,
  #     labels=c(.02,NA,.01,NA,0,NA,.01,NA,.02))
  axis(side=1)
  legend("topleft","Male",bty="n")
  legend("topright","Female",bty="n")
  
  for (i in 2:n){
    lines(-matrix_pop_pyr[i,1:max_age],age, lwd=1, lty=lty[i%%length(lty)+1],
          col=colM[i%%length(col)+1], ...)
    lines(matrix_pop_pyr[i,(max_age+1):(2*max_age)],age, lwd=1, lty=lty[i%%length(lty)+1],
          col=colF[i%%length(col)+1], ...)
  }
}

# lines_pop_pyr_1y Adds to an existing plot a lines representing 
#                  a population pyramids, precision of 1 yr
# Arguments:
#
# age:   ages at which each row of matrix_pop_pyr is evaluated 
# pop_pyr:  a population pyramid, first Male, then Female
# orderM:  -1 (1) if Male is sorted in decreasing (increasing) order
lines_pop_pyr <- function(age=NULL, pop_pyr, orderM = -1, 
                          lty=1, lwd=1, 
                          col=1, colM=col, colF=col, ...){
  pop_pyr <- as.numeric(pop_pyr)
  max_age <- length(pop_pyr)/2
  if (orderM==-1) pop_pyr[1:max_age] <- pop_pyr[max_age:1]
  if (is.null(age)) age <- 1:max_age -1
  lines(-pop_pyr[1:max_age],age, lwd=lwd, lty=lty, col=colM, ...)
  lines(pop_pyr[(max_age+1):(2*max_age)],age, lwd=lwd, lty=lty, col=colF, ...)
}
``` 

```{r, fig.height=5,fig.width=10} 
Age.1 <- ppDemog$age[ppDemog$age>0]
par(mfrow=c(1,2))
matplot_pop_pyr_1y(Age.1, t(ppDemog$rate$Total),col=8, 
     main=paste0(Country[ctr,1]," (",Year[1],"-", rev(Year)[1],")"))
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1],lwd=4)
eig_val_1 <- var(ppDemog.fit$coeff[,2])
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1]+sqrt(eig_val_1)*ppDemog.fit$basis[,2],lwd=4,col="red",lty=3)
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1]-sqrt(eig_val_1)*ppDemog.fit$basis[,2],lwd=4,col="blue",lty=3)
legend(-.011, 90,c("mean + 1st FPC ", "mean", "mean - 1st FPC "),
       lty=c(3,1,3), col=c(2,1,4), lwd=3, bty="n",seg.len = 2, cex=.75)
title(xlab=paste0("1st FPC: ",round(100*ppDemog.fit$varprop[1],1),"% variation"), bty="n")

matplot_pop_pyr_1y(Age.1, t(ppDemog$rate$Total),col=8, 
     main=paste0(Country[ctr,1],"(",Year[1],"-", rev(Year)[1],")"))
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1],lwd=4)
eig_val_2 <- var(ppDemog.fit$coeff[,3])
cte=1
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1]+cte*sqrt(eig_val_2)*ppDemog.fit$basis[,3],lwd=4,col="red",lty=3)
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1]-cte*sqrt(eig_val_2)*ppDemog.fit$basis[,3],lwd=4,col="blue",lty=3)
legend(-.011, 90,c("mean + 2nd FPC ", "mean", "mean - 2nd FPC "),
       lty=c(3,1,3), col=c(2,1,4), lwd=3, bty="n",seg.len = 2, cex=.75)

title(xlab=paste0("2nd FPC: ",round(100*ppDemog.fit$varprop[2],1),"% variation"), bty="n")
```

```{r,warning=FALSE, fig.height=5,fig.width=5} 
matplot_pop_pyr_1y(Age.1,t(ppDemog$rate$Total), datatype = "rate", col=8,
     main=paste0(Country[ctr,1],
                 ": absolute population (",
                 Year[1],"-", rev(Year)[1]+horiz,")"),
     xlim=550)
col <- rainbow(horiz, start=0, end=1)
for (i in (1:horiz)){ 
  lines_pop_pyr(Age.1,ppDemog.fcast$rate$total[,i], col=col[i%%length(col)+1])
}
```


## Colombia, relative population pyramids

```{r, warning=FALSE} 
ctr <- 'CO' 
ppDemog <- demogdata(data=t(PopPyrRelSm[ctr,,]), 
                     pop=t(PopPyrSm[ctr,,]), 
                     ages=egAge.1, years=Year, 
                     type= "mortality", label=Country[ctr,1],
                     name="Total", lambda=1) 
plot(ppDemog, datatype = "rate", # It is possible to use datatype="pop"
     main=paste0(Country[ctr,1],": relative population (",Year[1],"-", rev(Year)[1],")")) 
```

### Modeling and forecasting popultion pyramids


```{r}
ppDemog.fit <- fdm(ppDemog, order=2)
ppDemog.fit
```

```{r}
par(mar=c(4,4,1.5,1))
plot(ppDemog.fit)
```

Note in the previous graphics that the **Main effects** are negative in this example.
There is no clear reason for this.
In fact, here the true estimation of the mean is not the element `basis[,1]` of the fitted model (as in the previous example) but instead it is `1+basis[,1]`. 


```{r, fig.height=10,fig.width=8}
par(mfrow=c(2,1))
plot(ppDemog,col=8, 
     main=paste0(Country[ctr,1],": relative population (",Year[1],"-", rev(Year)[1],")"))
lines(ppDemog$age, 1+ppDemog.fit$basis[,1],lwd=4)
eig_val_1 <- var(ppDemog.fit$coeff[,2])
lines(ppDemog$age, 1+ppDemog.fit$basis[,1]+sqrt(eig_val_1)*ppDemog.fit$basis[,2],lwd=4,col="red",lty=3)
lines(ppDemog$age, 1+ppDemog.fit$basis[,1]-sqrt(eig_val_1)*ppDemog.fit$basis[,2],lwd=4,col="blue",lty=3)
legend("topleft",c("mean + 1st FPC ", "mean", "mean - 1st FPC "),
       lty=c(3,1,3), col=c(2,1,4), lwd=4, bty="n",seg.len = 1.5)
legend("topright",paste0("1st FPC: ",round(100*ppDemog.fit$varprop[1],1),"% variation"), bty="n")


plot(ppDemog,col=8, 
     main=paste0(Country[ctr,1],": relative population (",Year[1],"-", rev(Year)[1],")"))
lines(ppDemog$age, 1+ppDemog.fit$basis[,1],lwd=4)
eig_val_2 <- var(ppDemog.fit$coeff[,3])
cte=2
lines(ppDemog$age, 1+ppDemog.fit$basis[,1]+cte*sqrt(eig_val_2)*ppDemog.fit$basis[,3],lwd=4,col="red",lty=3)
lines(ppDemog$age, 1+ppDemog.fit$basis[,1]-cte*sqrt(eig_val_2)*ppDemog.fit$basis[,3],lwd=4,col="blue",lty=3)
legend("topleft",c("mean + 2nd FPC ", "mean", "mean - 2nd FPC "),
       lty=c(3,1,3), col=c(2,1,4), lwd=4, bty="n",seg.len = 1.5)
legend("topright",paste0("2nd FPC: ",round(100*ppDemog.fit$varprop[2],1),"% variation"), bty="n")
```

```{r}
plot(ppDemog.fit$coeff[,2],ppDemog.fit$coeff[,3],type="l",as=1,cex=.5,
     main="1st versus 2nd FPC scores of each calendar years",
     xlab="beta1: Scores at 1st FPC", ylab="beta2: Scores at 2nd FPC")
abline(v=0,h=0,col=8)
```

```{r}
plot(ppDemog.fit$coeff[,2:3], main="1st and 2nd FPC scores as time series")
```

Now, forecasts are computed for a horizon of `r (horiz<-20)` years: 
```{r}
if (!exists("horiz")) horiz <- 20
ppDemog.fcast <- forecast(ppDemog.fit,h=horiz)
models(ppDemog.fcast)
```

```{r}
par(mar=c(4,4,1.5,1))
plot(ppDemog.fcast,'c')
```

```{r}
plot(ppDemog.fcast,
     main=paste0(Country[ctr,1],": relative population (",rev(Year)[1]+1,"-", rev(Year)[1]+horiz,")"))
```

```{r,warning=FALSE} 
plot(ppDemog, datatype = "rate", col=8,
     main=paste0(Country[ctr,1],": relative population (",Year[1],"-", rev(Year)[1]+horiz,")"))
plot(ppDemog.fcast,add=TRUE)
```

### Ploting results as population pyramids

We plot now as population pyramids the modeling and forecasting results.

```{r, echo=FALSE}
# matplot_pop_pyr_1y matplot for a population pyramids dataset
#                    with precision of 1 yr
# Arguments:
#
# age:   ages at which each row of matrix_pop_pyr is evaluated 
# matrix_pop_pyr 
#    Each row:    a population pyramid, first Male, then Female
#    Each column: an age, negative for Male, positive for Female
# orderM:  -1 (1) if Male is sorted in decreasing (increasing) order
matplot_pop_pyr_1y <- 
  function(age=NULL, matrix_pop_pyr, orderM = -1, 
           col=1:8, colM=col, colF=col, lty=1:8,
           main="",
           xlim=max(abs(matrix_pop_pyr)), ...){
  max_age <- dim(matrix_pop_pyr)[2]/2
  if (orderM==-1) 
    matrix_pop_pyr[,1:max_age] <- matrix_pop_pyr[,max_age:1]
  n <- dim(matrix_pop_pyr)[1]
  pop_pyr <- as.numeric(matrix_pop_pyr[1,])
  if (is.null(age)){
    age <- 1:max_age -1
  } else {
    age <- age[age>0]
  }
  plot(-pop_pyr[1:max_age],age, type="l", lwd=1, col=colM[1],
       lty=lty[1],
       xlim=xlim*c(-1,1), ylim=c(0,100),
       xlab="",
       ylab="Age",
       main=main,
       axes=FALSE, ...)
  lines(pop_pyr[(max_age+1):(2*max_age)],age, lwd=1, lty=lty[1], col=colF[1], ...)
  abline(h=0)
  abline(v=0,col=8)
  segments(x0=rep(-.0005,5),y0=seq(20,100,by=20),x1=rep(.0005,5),col=8)
  axis(side=2, at=seq(0,100,by=20))
  #axis(side=1, at=seq(-.02,.02,by=.005), pos=0,
  #     labels=c(.02,NA,.01,NA,0,NA,.01,NA,.02))
  axis(side=1)
  legend("topleft","Male",bty="n")
  legend("topright","Female",bty="n")
  
  for (i in 2:n){
    lines(-matrix_pop_pyr[i,1:max_age],age, lwd=1, lty=lty[i%%length(lty)+1],
          col=colM[i%%length(col)+1], ...)
    lines(matrix_pop_pyr[i,(max_age+1):(2*max_age)],age, lwd=1, lty=lty[i%%length(lty)+1],
          col=colF[i%%length(col)+1], ...)
  }
}

# lines_pop_pyr_1y Adds to an existing plot a lines representing 
#                  a population pyramids, precision of 1 yr
# Arguments:
#
# age:   ages at which each row of matrix_pop_pyr is evaluated 
# pop_pyr:  a population pyramid, first Male, then Female
# orderM:  -1 (1) if Male is sorted in decreasing (increasing) order
lines_pop_pyr <- function(age=NULL, pop_pyr, orderM = -1, 
                          lty=1, lwd=1, 
                          col=1, colM=col, colF=col, ...){
  pop_pyr <- as.numeric(pop_pyr)
  max_age <- length(pop_pyr)/2
  if (orderM==-1) pop_pyr[1:max_age] <- pop_pyr[max_age:1]
  if (is.null(age)) age <- 1:max_age -1
  lines(-pop_pyr[1:max_age],age, lwd=lwd, lty=lty, col=colM, ...)
  lines(pop_pyr[(max_age+1):(2*max_age)],age, lwd=lwd, lty=lty, col=colF, ...)
}
``` 

```{r, fig.height=5,fig.width=10} 
Age.1 <- ppDemog$age[ppDemog$age>0]
par(mfrow=c(1,2))
matplot_pop_pyr_1y(Age.1, t(ppDemog$rate$Total),col=8, 
     main=paste0(Country[ctr,1]," (",Year[1],"-", rev(Year)[1],")"))
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1],lwd=4)
eig_val_1 <- var(ppDemog.fit$coeff[,2])
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1]+sqrt(eig_val_1)*ppDemog.fit$basis[,2],lwd=4,col="red",lty=3)
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1]-sqrt(eig_val_1)*ppDemog.fit$basis[,2],lwd=4,col="blue",lty=3)
legend(-0.02, 90,c("mean + 1st FPC ", "mean", "mean - 1st FPC "),
       lty=c(3,1,3), col=c(2,1,4), lwd=3, bty="n",seg.len = 2, cex=.75)
title(xlab=paste0("1st FPC: ",round(100*ppDemog.fit$varprop[1],1),"% variation"), bty="n")

matplot_pop_pyr_1y(Age.1, t(ppDemog$rate$Total),col=8, 
     main=paste0(Country[ctr,1],"(",Year[1],"-", rev(Year)[1],")"))
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1],lwd=4)
eig_val_2 <- var(ppDemog.fit$coeff[,3])
cte=2
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1]+cte*sqrt(eig_val_2)*ppDemog.fit$basis[,3],lwd=4,col="red",lty=3)
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1]-cte*sqrt(eig_val_2)*ppDemog.fit$basis[,3],lwd=4,col="blue",lty=3)
legend(-0.02, 90,c("mean + 2nd FPC ", "mean", "mean - 2nd FPC "),
       lty=c(3,1,3), col=c(2,1,4), lwd=3, bty="n",seg.len = 2, cex=.75)

title(xlab=paste0("2nd FPC: ",round(100*ppDemog.fit$varprop[2],1),"% variation"), bty="n")
```

```{r,warning=FALSE, fig.height=5,fig.width=5} 
matplot_pop_pyr_1y(Age.1,t(ppDemog$rate$Total), datatype = "rate", col=8,
     main=paste0(Country[ctr,1],
                 ": relative population (",Year[1],"-", rev(Year)[1]+horiz,")"))
col <- rainbow(horiz, start=0, end=1)
for (i in (1:horiz)){ 
  lines_pop_pyr(Age.1,ppDemog.fcast$rate$total[,i], col=col[i%%length(col)+1])
}
```


## Spain, absolute population pyramids

```{r, warning=FALSE} 
ctr <- 'ES' 
ppDemog <- demogdata(data=t(PopPyrSm[ctr,,]), 
                     pop=t(PopPyrSm[ctr,,]), 
                     ages=egAge.1, years=Year, 
                     type= "mortality", label=Country[ctr,1],
                     name="Total", lambda=1) 
plot(ppDemog, datatype = "rate", # It is possible to use datatype="pop"
     main=paste0(Country[ctr,1],": absolute population (",Year[1],"-", rev(Year)[1],")")) 
```

### Modeling and forecasting popultion pyramids


```{r}
ppDemog.fit <- fdm(ppDemog, order=2)
ppDemog.fit
```

```{r}
par(mar=c(4,4,1.5,1))
plot(ppDemog.fit)
```

<!-- Note in the previous graphics that the **Main effects** are positive in this example.--> 

```{r, fig.height=10,fig.width=8}
par(mfrow=c(2,1))
plot(ppDemog,col=8, 
     main=paste0(Country[ctr,1],": absolute population (",Year[1],"-", rev(Year)[1],")"))
lines(ppDemog$age, 1+ppDemog.fit$basis[,1],lwd=4)
eig_val_1 <- var(ppDemog.fit$coeff[,2])
lines(ppDemog$age, 1+ppDemog.fit$basis[,1]+sqrt(eig_val_1)*ppDemog.fit$basis[,2],lwd=4,col="red",lty=3)
lines(ppDemog$age, 1+ppDemog.fit$basis[,1]-sqrt(eig_val_1)*ppDemog.fit$basis[,2],lwd=4,col="blue",lty=3)
legend("topleft",c("mean + 1st FPC ", "mean", "mean - 1st FPC "),
       lty=c(3,1,3), col=c(2,1,4), lwd=4, bty="n",seg.len = 1.5)
legend("topright",paste0("1st FPC: ",round(100*ppDemog.fit$varprop[1],1),"% variation"), bty="n")


plot(ppDemog,col=8, 
     main=paste0(Country[ctr,1],": absolute population (",Year[1],"-", rev(Year)[1],")"))
lines(ppDemog$age, 1+ppDemog.fit$basis[,1],lwd=4)
eig_val_2 <- var(ppDemog.fit$coeff[,3])
cte=1
lines(ppDemog$age, 1+ppDemog.fit$basis[,1]+cte*sqrt(eig_val_2)*ppDemog.fit$basis[,3],lwd=4,col="red",lty=3)
lines(ppDemog$age, 1+ppDemog.fit$basis[,1]-cte*sqrt(eig_val_2)*ppDemog.fit$basis[,3],lwd=4,col="blue",lty=3)
legend("topleft",c("mean + 2nd FPC ", "mean", "mean - 2nd FPC "),
       lty=c(3,1,3), col=c(2,1,4), lwd=4, bty="n",seg.len = 1.5)
legend("topright",paste0("2nd FPC: ",round(100*ppDemog.fit$varprop[2],1),"% variation"), bty="n")
```

```{r}
plot(ppDemog.fit$coeff[,2],ppDemog.fit$coeff[,3],type="l",as=1,cex=.5,
     main="1st versus 2nd FPC scores of each calendar years",
     xlab="beta1: Scores at 1st FPC", ylab="beta2: Scores at 2nd FPC")
abline(v=0,h=0,col=8)
```

```{r}
plot(ppDemog.fit$coeff[,2:3], main="1st and 2nd FPC scores as time series")
```

Now, forecasts are computed for a horizon of `r (horiz<-20)` years: 
```{r}
if (!exists("horiz")) horiz <- 20
ppDemog.fcast <- forecast(ppDemog.fit,h=horiz)
models(ppDemog.fcast)
```

```{r}
par(mar=c(4,4,1.5,1))
plot(ppDemog.fcast,'c')
```

```{r}
plot(ppDemog.fcast,
     main=paste0(Country[ctr,1],": absolute population (",rev(Year)[1]+1,"-", rev(Year)[1]+horiz,")"))
```

```{r,warning=FALSE} 
plot(ppDemog, datatype = "rate", col=8,
     main=paste0(Country[ctr,1],": absolute population (",Year[1],"-", rev(Year)[1]+horiz,")"))
plot(ppDemog.fcast,add=TRUE)
```

### Ploting results as population pyramids

We plot now as population pyramids the modeling and forecasting results.

```{r, echo=FALSE}
# matplot_pop_pyr_1y matplot for a population pyramids dataset
#                    with precision of 1 yr
# Arguments:
#
# age:   ages at which each row of matrix_pop_pyr is evaluated 
# matrix_pop_pyr 
#    Each row:    a population pyramid, first Male, then Female
#    Each column: an age, negative for Male, positive for Female
# orderM:  -1 (1) if Male is sorted in decreasing (increasing) order
matplot_pop_pyr_1y <- 
  function(age=NULL, matrix_pop_pyr, orderM = -1, 
           col=1:8, colM=col, colF=col, lty=1:8,
           main="",
           xlim=max(abs(matrix_pop_pyr)), ...){
  max_age <- dim(matrix_pop_pyr)[2]/2
  if (orderM==-1) 
    matrix_pop_pyr[,1:max_age] <- matrix_pop_pyr[,max_age:1]
  n <- dim(matrix_pop_pyr)[1]
  pop_pyr <- as.numeric(matrix_pop_pyr[1,])
  if (is.null(age)){
    age <- 1:max_age -1
  } else {
    age <- age[age>0]
  }
  plot(-pop_pyr[1:max_age],age, type="l", lwd=1, col=colM[1],
       lty=lty[1],
       xlim=xlim*c(-1,1), ylim=c(0,100),
       xlab="",
       ylab="Age",
       main=main,
       axes=FALSE, ...)
  lines(pop_pyr[(max_age+1):(2*max_age)],age, lwd=1, lty=lty[1], col=colF[1], ...)
  abline(h=0)
  abline(v=0,col=8)
  segments(x0=rep(-.0005,5),y0=seq(20,100,by=20),x1=rep(.0005,5),col=8)
  axis(side=2, at=seq(0,100,by=20))
  #axis(side=1, at=seq(-.02,.02,by=.005), pos=0,
  #     labels=c(.02,NA,.01,NA,0,NA,.01,NA,.02))
  axis(side=1)
  legend("topleft","Male",bty="n")
  legend("topright","Female",bty="n")
  
  for (i in 2:n){
    lines(-matrix_pop_pyr[i,1:max_age],age, lwd=1, lty=lty[i%%length(lty)+1],
          col=colM[i%%length(col)+1], ...)
    lines(matrix_pop_pyr[i,(max_age+1):(2*max_age)],age, lwd=1, lty=lty[i%%length(lty)+1],
          col=colF[i%%length(col)+1], ...)
  }
}

# lines_pop_pyr_1y Adds to an existing plot a lines representing 
#                  a population pyramids, precision of 1 yr
# Arguments:
#
# age:   ages at which each row of matrix_pop_pyr is evaluated 
# pop_pyr:  a population pyramid, first Male, then Female
# orderM:  -1 (1) if Male is sorted in decreasing (increasing) order
lines_pop_pyr <- function(age=NULL, pop_pyr, orderM = -1, 
                          lty=1, lwd=1, 
                          col=1, colM=col, colF=col, ...){
  pop_pyr <- as.numeric(pop_pyr)
  max_age <- length(pop_pyr)/2
  if (orderM==-1) pop_pyr[1:max_age] <- pop_pyr[max_age:1]
  if (is.null(age)) age <- 1:max_age -1
  lines(-pop_pyr[1:max_age],age, lwd=lwd, lty=lty, col=colM, ...)
  lines(pop_pyr[(max_age+1):(2*max_age)],age, lwd=lwd, lty=lty, col=colF, ...)
}
``` 

```{r, fig.height=5,fig.width=10} 
Age.1 <- ppDemog$age[ppDemog$age>0]
par(mfrow=c(1,2))
matplot_pop_pyr_1y(Age.1, t(ppDemog$rate$Total),col=8, 
     main=paste0(Country[ctr,1]," (",Year[1],"-", rev(Year)[1],")"))
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1],lwd=4)
eig_val_1 <- var(ppDemog.fit$coeff[,2])
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1]+sqrt(eig_val_1)*ppDemog.fit$basis[,2],lwd=4,col="red",lty=3)
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1]-sqrt(eig_val_1)*ppDemog.fit$basis[,2],lwd=4,col="blue",lty=3)
legend(-470, 90,c("mean + 1st FPC ", "mean", "mean - 1st FPC "),
       lty=c(3,1,3), col=c(2,1,4), lwd=3, bty="n",seg.len = 2, cex=.75)
title(xlab=paste0("1st FPC: ",round(100*ppDemog.fit$varprop[1],1),"% variation"), bty="n")

matplot_pop_pyr_1y(Age.1, t(ppDemog$rate$Total),col=8, 
     main=paste0(Country[ctr,1],"(",Year[1],"-", rev(Year)[1],")"))
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1],lwd=4)
eig_val_2 <- var(ppDemog.fit$coeff[,3])
cte=1
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1]+cte*sqrt(eig_val_2)*ppDemog.fit$basis[,3],lwd=4,col="red",lty=3)
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1]-cte*sqrt(eig_val_2)*ppDemog.fit$basis[,3],lwd=4,col="blue",lty=3)
legend(-470, 90,c("mean + 2nd FPC ", "mean", "mean - 2nd FPC "),
       lty=c(3,1,3), col=c(2,1,4), lwd=3, bty="n",seg.len = 2, cex=.75)

title(xlab=paste0("2nd FPC: ",round(100*ppDemog.fit$varprop[2],1),"% variation"), bty="n")
```

```{r,warning=FALSE, fig.height=5,fig.width=5} 
matplot_pop_pyr_1y(Age.1,t(ppDemog$rate$Total), datatype = "rate", col=8,
     main=paste0(Country[ctr,1],
                 ": absolute population (",Year[1],"-", rev(Year)[1]+horiz,")"))
col <- rainbow(horiz, start=0, end=1)
for (i in (1:horiz)){ 
  lines_pop_pyr(Age.1,ppDemog.fcast$rate$total[,i], col=col[i%%length(col)+1])
}
```

## Spain, relative population pyramids

```{r, warning=FALSE} 
ctr <- 'ES' 
ppDemog <- demogdata(data=t(PopPyrRelSm[ctr,,]), 
                     pop=t(PopPyrSm[ctr,,]), 
                     ages=egAge.1, years=Year, 
                     type= "mortality", label=Country[ctr,1],
                     name="Total", lambda=1) 
plot(ppDemog, datatype = "rate", # It is possible to use datatype="pop"
     main=paste0(Country[ctr,1],": relative population (",Year[1],"-", rev(Year)[1],")")) 
```

### Modeling and forecasting popultion pyramids

```{r}
ppDemog.fit <- fdm(ppDemog, order=2)
ppDemog.fit
```

```{r}
par(mar=c(4,4,1.5,1))
plot(ppDemog.fit)
```

Note in the previous graphics that the **Main effects** are negative in this example.
There is no clear reason for this.
In fact, here the true estimation of the mean is not the element `basis[,1]` of the fitted model (as in the previous example) but instead it is `1+basis[,1]`. 

```{r, fig.height=10,fig.width=8}
par(mfrow=c(2,1))
plot(ppDemog,col=8, 
     main=paste0(Country[ctr,1],": relative population (",Year[1],"-", rev(Year)[1],")"))
lines(ppDemog$age, 1+ppDemog.fit$basis[,1],lwd=4)
eig_val_1 <- var(ppDemog.fit$coeff[,2])
lines(ppDemog$age, 1+ppDemog.fit$basis[,1]+sqrt(eig_val_1)*ppDemog.fit$basis[,2],lwd=4,col="red",lty=3)
lines(ppDemog$age, 1+ppDemog.fit$basis[,1]-sqrt(eig_val_1)*ppDemog.fit$basis[,2],lwd=4,col="blue",lty=3)
legend("topleft",c("mean + 1st FPC ", "mean", "mean - 1st FPC "),
       lty=c(3,1,3), col=c(2,1,4), lwd=4, bty="n",seg.len = 1.5)
legend("topright",paste0("1st FPC: ",round(100*ppDemog.fit$varprop[1],1),"% variation"), bty="n")


plot(ppDemog,col=8, 
     main=paste0(Country[ctr,1],": relative population (",Year[1],"-", rev(Year)[1],")"))
lines(ppDemog$age, 1+ppDemog.fit$basis[,1],lwd=4)
eig_val_2 <- var(ppDemog.fit$coeff[,3])
cte=1
lines(ppDemog$age, 1+ppDemog.fit$basis[,1]+cte*sqrt(eig_val_2)*ppDemog.fit$basis[,3],lwd=4,col="red",lty=3)
lines(ppDemog$age, 1+ppDemog.fit$basis[,1]-cte*sqrt(eig_val_2)*ppDemog.fit$basis[,3],lwd=4,col="blue",lty=3)
legend("topleft",c("mean + 2nd FPC ", "mean", "mean - 2nd FPC "),
       lty=c(3,1,3), col=c(2,1,4), lwd=4, bty="n",seg.len = 1.5)
legend("topright",paste0("2nd FPC: ",round(100*ppDemog.fit$varprop[2],1),"% variation"), bty="n")
```

```{r}
plot(ppDemog.fit$coeff[,2],ppDemog.fit$coeff[,3],type="l",as=1,cex=.5,
     main="1st versus 2nd FPC scores of each calendar years",
     xlab="beta1: Scores at 1st FPC", ylab="beta2: Scores at 2nd FPC")
abline(v=0,h=0,col=8)
```

```{r}
plot(ppDemog.fit$coeff[,2:3], main="1st and 2nd FPC scores as time series")
```

Now, forecasts are computed for a horizon of `r (horiz<-20)` years: 
```{r}
if (!exists("horiz")) horiz <- 20
ppDemog.fcast <- forecast(ppDemog.fit,h=horiz)
models(ppDemog.fcast)
```

```{r}
par(mar=c(4,4,1.5,1))
plot(ppDemog.fcast,'c')
```

```{r}
plot(ppDemog.fcast,
     main=paste0(Country[ctr,1],": relative population (",rev(Year)[1]+1,"-", rev(Year)[1]+horiz,")"))
```

```{r,warning=FALSE} 
plot(ppDemog, datatype = "rate", col=8,
     main=paste0(Country[ctr,1],": relative population (",Year[1],"-", rev(Year)[1]+horiz,")"))
plot(ppDemog.fcast,add=TRUE)
```

### Ploting results as population pyramids

We plot now as population pyramids the modeling and forecasting results.

```{r, echo=FALSE}
# matplot_pop_pyr_1y matplot for a population pyramids dataset
#                    with precision of 1 yr
# Arguments:
#
# age:   ages at which each row of matrix_pop_pyr is evaluated 
# matrix_pop_pyr 
#    Each row:    a population pyramid, first Male, then Female
#    Each column: an age, negative for Male, positive for Female
# orderM:  -1 (1) if Male is sorted in decreasing (increasing) order
matplot_pop_pyr_1y <- 
  function(age=NULL, matrix_pop_pyr, orderM = -1, 
           col=1:8, colM=col, colF=col, lty=1:8,
           main="",
           xlim=max(abs(matrix_pop_pyr)), ...){
  max_age <- dim(matrix_pop_pyr)[2]/2
  if (orderM==-1) 
    matrix_pop_pyr[,1:max_age] <- matrix_pop_pyr[,max_age:1]
  n <- dim(matrix_pop_pyr)[1]
  pop_pyr <- as.numeric(matrix_pop_pyr[1,])
  if (is.null(age)){
    age <- 1:max_age -1
  } else {
    age <- age[age>0]
  }
  plot(-pop_pyr[1:max_age],age, type="l", lwd=1, col=colM[1],
       lty=lty[1],
       xlim=xlim*c(-1,1), ylim=c(0,100),
       xlab="",
       ylab="Age",
       main=main,
       axes=FALSE, ...)
  lines(pop_pyr[(max_age+1):(2*max_age)],age, lwd=1, lty=lty[1], col=colF[1], ...)
  abline(h=0)
  abline(v=0,col=8)
  segments(x0=rep(-.0005,5),y0=seq(20,100,by=20),x1=rep(.0005,5),col=8)
  axis(side=2, at=seq(0,100,by=20))
  #axis(side=1, at=seq(-.02,.02,by=.005), pos=0,
  #     labels=c(.02,NA,.01,NA,0,NA,.01,NA,.02))
  axis(side=1)
  legend("topleft","Male",bty="n")
  legend("topright","Female",bty="n")
  
  for (i in 2:n){
    lines(-matrix_pop_pyr[i,1:max_age],age, lwd=1, lty=lty[i%%length(lty)+1],
          col=colM[i%%length(col)+1], ...)
    lines(matrix_pop_pyr[i,(max_age+1):(2*max_age)],age, lwd=1, lty=lty[i%%length(lty)+1],
          col=colF[i%%length(col)+1], ...)
  }
}

# lines_pop_pyr_1y Adds to an existing plot a lines representing 
#                  a population pyramids, precision of 1 yr
# Arguments:
#
# age:   ages at which each row of matrix_pop_pyr is evaluated 
# pop_pyr:  a population pyramid, first Male, then Female
# orderM:  -1 (1) if Male is sorted in decreasing (increasing) order
lines_pop_pyr <- function(age=NULL, pop_pyr, orderM = -1, 
                          lty=1, lwd=1, 
                          col=1, colM=col, colF=col, ...){
  pop_pyr <- as.numeric(pop_pyr)
  max_age <- length(pop_pyr)/2
  if (orderM==-1) pop_pyr[1:max_age] <- pop_pyr[max_age:1]
  if (is.null(age)) age <- 1:max_age -1
  lines(-pop_pyr[1:max_age],age, lwd=lwd, lty=lty, col=colM, ...)
  lines(pop_pyr[(max_age+1):(2*max_age)],age, lwd=lwd, lty=lty, col=colF, ...)
}
``` 

```{r, fig.height=5,fig.width=10} 
Age.1 <- ppDemog$age[ppDemog$age>0]
par(mfrow=c(1,2))
matplot_pop_pyr_1y(Age.1, t(ppDemog$rate$Total),col=8, 
     main=paste0(Country[ctr,1]," (",Year[1],"-", rev(Year)[1],")"))
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1],lwd=4)
eig_val_1 <- var(ppDemog.fit$coeff[,2])
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1]+sqrt(eig_val_1)*ppDemog.fit$basis[,2],lwd=4,col="red",lty=3)
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1]-sqrt(eig_val_1)*ppDemog.fit$basis[,2],lwd=4,col="blue",lty=3)
legend(-.011, 90,c("mean + 1st FPC ", "mean", "mean - 1st FPC "),
       lty=c(3,1,3), col=c(2,1,4), lwd=3, bty="n",seg.len = 2, cex=.75)
title(xlab=paste0("1st FPC: ",round(100*ppDemog.fit$varprop[1],1),"% variation"), bty="n")

matplot_pop_pyr_1y(Age.1, t(ppDemog$rate$Total),col=8, 
     main=paste0(Country[ctr,1],"(",Year[1],"-", rev(Year)[1],")"))
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1],lwd=4)
eig_val_2 <- var(ppDemog.fit$coeff[,3])
cte=1
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1]+cte*sqrt(eig_val_2)*ppDemog.fit$basis[,3],lwd=4,col="red",lty=3)
lines_pop_pyr(Age.1, 1+ppDemog.fit$basis[,1]-cte*sqrt(eig_val_2)*ppDemog.fit$basis[,3],lwd=4,col="blue",lty=3)
legend(-.011, 90,c("mean + 2nd FPC ", "mean", "mean - 2nd FPC "),
       lty=c(3,1,3), col=c(2,1,4), lwd=3, bty="n",seg.len = 2, cex=.75)

title(xlab=paste0("2nd FPC: ",round(100*ppDemog.fit$varprop[2],1),"% variation"), bty="n")
```


```{r,warning=FALSE, fig.height=5,fig.width=5} 
matplot_pop_pyr_1y(Age.1,t(ppDemog$rate$Total), datatype = "rate", col=8,
     main=paste0(Country[ctr,1],
                 ": relative population (",Year[1],"-", rev(Year)[1]+horiz,")"))
col <- rainbow(horiz, start=0, end=1)
for (i in (1:horiz)){ 
  lines_pop_pyr(Age.1,ppDemog.fcast$rate$total[,i], col=col[i%%length(col)+1])
}
```

